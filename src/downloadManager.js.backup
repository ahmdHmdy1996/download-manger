const fs = require('fs');
const path = require('path');
const axios = require('axios');
const { EventEmitter } = require('events');
const crypto = require('crypto');

class DownloadManager extends EventEmitter {
  constructor(store) {
    super();
    this.downloads = new Map();
    this.store = store;
    this.settings = {
      maxConnections: 8,
      speedLimit: 0,
      autoStart: true
    };
    
    // Load saved downloads from store
    this.loadSavedDownloads();
  }
  
  loadSavedDownloads() {
    const savedDownloads = this.store.get('downloads') || [];
    savedDownloads.forEach(download => {
      this.downloads.set(download.id, download);
    });
  }
  
  saveDownloads() {
    const downloadsArray = Array.from(this.downloads.values()).map(d => ({
      id: d.id,
      url: d.url,
      filename: d.filename,
      filePath: d.filePath,
      totalSize: d.totalSize,
      downloadedSize: d.downloadedSize,
      speed: 0, // Reset speed on save
      status: d.status,
      supportsRanges: d.supportsRanges,
      error: d.error
    }));
    this.store.set('downloads', downloadsArray);
      const download = {
        id: downloadId,
        url,
        filename,
        filePath,
        totalSize,
        downloadedSize: 0,
        speed: 0,
        status: 'waiting', // waiting, downloading, paused, completed, error, cancelled
        supportsRanges,
        chunks: [],
        startTime: Date.now(),
        error: null,
        abortController: null
      };
      
      this.downloads.set(downloadId, download);
      
      // Save to persistent storage
      this.saveDownloads();
      
      if (this.settings.autoStart) {
        this.startDownload(downloadId);
      }
      
      return downloadId;
    } catch (error) {
      throw new Error(`Failed to add download: ${error.message}`);
    }
  }

  async startDownload(downloadId) {
    const download = this.downloads.get(downloadId);
    if (!download) return;
    
    download.status = 'downloading';
    download.startTime = Date.now();
    
    // Create abort controller for this download
    if (!download.abortController || download.abortController.signal.aborted) {
      download.abortController = new AbortController();
    }
    
    if (download.supportsRanges && download.totalSize > 1024 * 1024) {
      // Use multi-threaded download for files > 1MB that support ranges
      await this.multiThreadedDownload(download);
    } else {
      // Use single-threaded download
      await this.singleThreadedDownload(download);
    }
  }

  async singleThreadedDownload(download) {
    try {
      // Check if we're resuming
      const isResume = download.downloadedSize > 0 && fs.existsSync(download.filePath);
      const startByte = isResume ? download.downloadedSize : 0;
      
      // Open file in append mode if resuming, otherwise create new
      const writer = isResume 
        ? fs.createWriteStream(download.filePath, { flags: 'a' })
        : fs.createWriteStream(download.filePath);
      
      const axiosConfig = {
        method: 'GET',
        url: download.url,
        responseType: 'stream',
        timeout: 120000,
        signal: download.abortController.signal,
        headers: startByte > 0 ? { Range: `bytes=${startByte}-` } : {},
        httpsAgent: download.url.startsWith('https') ? new (require('https').Agent)({
          rejectUnauthorized: false,
          keepAlive: true
        }) : undefined,
        httpAgent: download.url.startsWith('http:') ? new (require('http').Agent)({
          keepAlive: true
        }) : undefined,
        onDownloadProgress: (progressEvent) => {
          download.downloadedSize = startByte + progressEvent.loaded;
          download.speed = this.calculateSpeed(download);
          
          this.emit('download-progress', download.id, {
            downloadedSize: download.downloadedSize,
            totalSize: download.totalSize,
            speed: download.speed,
            percentage: download.totalSize > 0 
              ? (download.downloadedSize / download.totalSize) * 100 
              : 0
          });
        }
      };
      
      const response = await axios(axiosConfig);
      
      response.data.pipe(writer);
      
      await new Promise((resolve, reject) => {
        writer.on('finish', resolve);
        writer.on('error', reject);
      });
      
      download.status = 'completed';
      this.saveDownloads();
      this.emit('download-completed', download.id);
      
    } catch (error) {
      if (download.status !== 'cancelled' && download.status !== 'paused') {
        download.status = 'error';
        download.error = error.message;
        this.saveDownloads();
        this.emit('download-error', download.id, error.message);
      }
    }
  }

  async multiThreadedDownload(download) {
    const numChunks = Math.min(this.settings.maxConnections, 8);
    const chunkSize = Math.ceil(download.totalSize / numChunks);
    
    // Create temp directory for chunks
    const tempDir = `${download.filePath}.chunks`;
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    // Create or restore chunks
    if (!download.chunks || download.chunks.length === 0) {
      download.chunks = [];
      for (let i = 0; i < numChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize - 1, download.totalSize - 1);
        
        // Check if chunk file exists (resuming)
        const chunkPath = path.join(tempDir, `chunk_${i}`);
        const downloaded = fs.existsSync(chunkPath) ? fs.statSync(chunkPath).size : 0;
        
        download.chunks.push({
          index: i,
          start,
          end,
          downloaded,
          status: downloaded >= (end - start + 1) ? 'completed' : 'pending',
          controller: new AbortController()
        });
      }
    } else {
      // Recreate abort controllers for existing chunks
      download.chunks.forEach(chunk => {
        if (!chunk.controller || chunk.controller.signal.aborted) {
          chunk.controller = new AbortController();
        }
      });
    }
    
    try {
      // Download all incomplete chunks in parallel
      await Promise.all(
        download.chunks
          .filter(chunk => chunk.status !== 'completed')
          .map(chunk => this.downloadChunk(download, chunk, tempDir))
      );
      
      // Merge chunks
      await this.mergeChunks(download, tempDir);
      
      download.status = 'completed';
      this.saveDownloads();
      this.emit('download-completed', download.id);
      
      // Clean up temp directory
      fs.rmSync(tempDir, { recursive: true, force: true });
      
    } catch (error) {
      if (download.status !== 'cancelled' && download.status !== 'paused') {
        download.status = 'error';
        download.error = error.message;
        this.saveDownloads();
        this.emit('download-error', download.id, error.message);
      }
    }
  }

  async downloadChunk(download, chunk, tempDir) {
    const chunkPath = path.join(tempDir, `chunk_${chunk.index}`);
    
    // Check if resuming this chunk
    const existingSize = chunk.downloaded || 0;
    const actualStart = chunk.start + existingSize;
    
    // Skip if chunk is already complete
    if (existingSize >= (chunk.end - chunk.start + 1)) {
      chunk.status = 'completed';
      return;
    }
    
    // Open in append mode if resuming
    const writer = existingSize > 0
      ? fs.createWriteStream(chunkPath, { flags: 'a' })
      : fs.createWriteStream(chunkPath);
    
    try {
      const axiosConfig = {
        method: 'GET',
        url: download.url,
        headers: {
          Range: `bytes=${actualStart}-${chunk.end}`
        },
        responseType: 'stream',
        signal: chunk.controller.signal,
        timeout: 60000,
        httpsAgent: download.url.startsWith('https') ? new (require('https').Agent)({
          rejectUnauthorized: false,
          keepAlive: true
        }) : undefined,
        httpAgent: download.url.startsWith('http:') ? new (require('http').Agent)({
          keepAlive: true
        }) : undefined,
        onDownloadProgress: (progressEvent) => {
          chunk.downloaded = existingSize + progressEvent.loaded;
          
          // Calculate total downloaded across all chunks
          download.downloadedSize = download.chunks.reduce(
            (sum, c) => sum + (c.downloaded || 0), 
            0
          );
          download.speed = this.calculateSpeed(download);
          
          this.emit('download-progress', download.id, {
            downloadedSize: download.downloadedSize,
            totalSize: download.totalSize,
            speed: download.speed,
            percentage: (download.downloadedSize / download.totalSize) * 100
          });
        }
      };
      
      const response = await axios(axiosConfig);
      
      chunk.status = 'downloading';
      response.data.pipe(writer);
      
      await new Promise((resolve, reject) => {
        writer.on('finish', resolve);
        writer.on('error', reject);
      });
      
      chunk.status = 'completed';
      
    } catch (error) {
      if (error.name !== 'CanceledError' && error.name !== 'AbortError') {
        chunk.status = 'error';
        throw error;
      }
    }
  }

  async mergeChunks(download, tempDir) {
    const writer = fs.createWriteStream(download.filePath);
    
    for (let i = 0; i < download.chunks.length; i++) {
      const chunkPath = path.join(tempDir, `chunk_${i}`);
      const data = fs.readFileSync(chunkPath);
      writer.write(data);
    }
    
    writer.end();
    
    await new Promise((resolve, reject) => {
      writer.on('finish', resolve);
      writer.on('error', reject);
    });
  }

  calculateSpeed(download) {
    const elapsedTime = (Date.now() - download.startTime) / 1000; // in seconds
    if (elapsedTime === 0) return 0;
    return download.downloadedSize / elapsedTime; // bytes per second
  }

  pauseDownload(downloadId) {
    const download = this.downloads.get(downloadId);
    if (!download || download.status !== 'downloading') return;
    
    download.status = 'paused';
    
    // Abort the download
    if (download.abortController) {
      download.abortController.abort();
    }
    
    // Abort all chunk downloads (for multi-threaded)
    if (download.chunks && download.chunks.length > 0) {
      download.chunks.forEach(chunk => {
        if (chunk.controller) {
          chunk.controller.abort();
        }
      });
    }
    
    this.saveDownloads();
  }

  resumeDownload(downloadId) {
    const download = this.downloads.get(downloadId);
    if (!download || download.status !== 'paused') return;
    
    this.startDownload(downloadId);
  }

  cancelDownload(downloadId) {
    const download = this.downloads.get(downloadId);
    if (!download) return;
    
    download.status = 'cancelled';
    
    // Abort all chunk downloads
    if (download.chunks.length > 0) {
      download.chunks.forEach(chunk => {
        if (chunk.controller) {
          chunk.controller.abort();
        }
      });
    }
    
    // Clean up temp files with better error handling
    const tempDir = `${download.filePath}.chunks`;
    if (fs.existsSync(tempDir)) {
      try {
        // Wait a bit for file handles to close
        setTimeout(() => {
          try {
            fs.rmSync(tempDir, { recursive: true, force: true, maxRetries: 3, retryDelay: 100 });
          } catch (err) {
            console.error('Failed to cleanup temp directory:', err.message);
          }
        }, 500);
      } catch (err) {
        console.error('Error scheduling cleanup:', err.message);
      }
    }
  }

  removeDownload(downloadId) {
    const download = this.downloads.get(downloadId);
    
    if (!download) {
      console.warn(`Download ${downloadId} not found`);
      return;
    }
    
    // Only cancel if download is active
    if (download.status === 'downloading' || download.status === 'waiting' || download.status === 'paused') {
      this.cancelDownload(downloadId);
    }
    
    // Delete from map and save
    this.downloads.delete(downloadId);
    this.saveDownloads();
    
    console.log(`Download ${downloadId} removed successfully`);
  }

  getAllDownloads() {
    return Array.from(this.downloads.values()).map(download => ({
      id: download.id,
      filename: download.filename,
      url: download.url,
      totalSize: download.totalSize,
      downloadedSize: download.downloadedSize,
      speed: download.speed,
      status: download.status,
      error: download.error,
      percentage: download.totalSize > 0 
        ? (download.downloadedSize / download.totalSize) * 100 
        : 0
    }));
  }

  updateSettings(settings) {
    this.settings = { ...this.settings, ...settings };
  }
}

module.exports = DownloadManager;
